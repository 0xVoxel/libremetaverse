From 7d907b03714aa9ac0d7abde33c1fe8c195e56dcb Mon Sep 17 00:00:00 2001
From: antoncl <anton.lauridsen@gmail.com>
Date: Mon, 15 Dec 2014 22:52:07 +0100
Subject: [PATCH 1/2] Documented LindenSkeleton mesh, which can "unpack" the
 skinweights on the mesh and which correctly handles eyeball lod mesh.

---
 OpenMetaverse/Rendering/LindenMesh.cs | 552 ++++++++++++++++++++++++----------
 Programs/AvatarPreview/GLMesh.cs      |  60 ++--
 2 files changed, 420 insertions(+), 192 deletions(-)

diff --git a/OpenMetaverse/Rendering/LindenMesh.cs b/OpenMetaverse/Rendering/LindenMesh.cs
index 799debd..a615d47 100644
--- a/OpenMetaverse/Rendering/LindenMesh.cs
+++ b/OpenMetaverse/Rendering/LindenMesh.cs
@@ -30,75 +30,187 @@ using System.IO;
 
 namespace OpenMetaverse.Rendering
 {
+    /// <summary>
+    /// Load and handle Linden Lab binary meshes.
+    /// </summary>
+    /// <remarks>
+    /// The exact definition of this file is a bit sketchy, especially concerning skin weights.
+    /// A good starting point is on the 
+    /// <a href="http://wiki.secondlife.com/wiki/Avatar_Appearance#Linden_binary_mesh_file">second life wiki</a>
+    /// </remarks>
     public class LindenMesh
     {
-        const string MESH_HEADER = "Linden Binary Mesh 1.0";
-        const string MORPH_FOOTER = "End Morphs";
+        const string MeshHeader = "Linden Binary Mesh 1.0";
+        const string MorphFooter = "End Morphs";
+        public LindenSkeleton Skeleton { get; private set; }    //!< The skeleton used to animate this mesh
 
         #region Mesh Structs
 
+        /// <summary>
+        /// Defines a polygon
+        /// </summary>
         public struct Face
         {
-            public short[] Indices;
+            public short[] Indices;                     //!< Indices into the vertex array
         }
 
+        /// <summary>
+        /// Structure of a vertex, No surprises there, except for the Detail tex coord
+        /// </summary>
+        /// <remarks>
+        /// The skinweights are a tad unconventional. The best explanation found is:
+        /// >Each weight actually contains two pieces of information. The number to the 
+        /// >left of the decimal point is the index of the joint and also implicitly 
+        /// >indexes to the following joint. The actual weight is to the right of the
+        /// >decimal point and interpolates between these two joints. The index is into
+        /// >an "expanded" list of joints, not just a linear array of the joints as
+        /// >defined in the skeleton file. In particular, any joint that has more than
+        /// >one child will be repeated in the list for each of its children.
+        ///
+        /// Maybe I'm dense, but that description seems to be a bit hard to build an
+        /// algorithm on. 
+        /// 
+        /// Esentially the weights are compressed into one floating point value.
+        /// 1. The whole number part is an index into an array of joints
+        /// 2. The fractional part is the weight that joint has
+        /// 3. If the fractional part is 0 (x.0000) then the vertex is 100% influenced by the specified joint
+        /// </remarks>
         public struct Vertex
         {
-            public Vector3 Coord;
-            public Vector3 Normal;
-            public Vector3 BiNormal;
-            public Vector2 TexCoord;
-            public Vector2 DetailTexCoord;
-            public float Weight;
-
+            public Vector3 Coord;                       //!< 3d co-ordinate of the vertex
+            public Vector3 Normal;                      //!< Normal of the vertex
+            public Vector3 BiNormal;                    //!< Bi normal of the vertex
+            public Vector2 TexCoord;                    //!< UV maping of the vertex
+            public Vector2 DetailTexCoord;              //!< Detailed? UV mapping
+            public float Weight;                        //!< Used to calculate the skin weights
+
+            /// <summary>
+            /// Provide a nice format for debugging
+            /// </summary>
+            /// <returns>Vertex definition as a string</returns>
             public override string ToString()
             {
-                return String.Format("Coord: {0} Norm: {1} BiNorm: {2} TexCoord: {3} DetailTexCoord: {4}", Coord, Normal, BiNormal, TexCoord, DetailTexCoord, Weight);
+                return String.Format("Coord: {0} Norm: {1} BiNorm: {2} TexCoord: {3} DetailTexCoord: {4}", Coord, Normal, BiNormal, TexCoord, DetailTexCoord);
             }
         }
 
+        /// <summary>
+        /// Describes deltas to apply to a vertex in order to morph a vertex
+        /// </summary>
         public struct MorphVertex
         {
-            public uint VertexIndex;
-            public Vector3 Coord;
-            public Vector3 Normal;
-            public Vector3 BiNormal;
-            public Vector2 TexCoord;
-
+            public uint VertexIndex;            //!< Index into the vertex list of the vertex to change
+            public Vector3 Coord;               //!< Delta position
+            public Vector3 Normal;              //!< Delta normal
+            public Vector3 BiNormal;            //!< Delta BiNormal
+            public Vector2 TexCoord;            //!< Delta UV mapping
+
+            /// <summary>
+            /// Provide a nice format for debugging
+            /// </summary>
+            /// <returns>MorphVertex definition as a string</returns>
             public override string ToString()
             {
                 return String.Format("Index: {0} Coord: {1} Norm: {2} BiNorm: {3} TexCoord: {4}", VertexIndex, Coord, Normal, BiNormal, TexCoord);
             }
         }
 
+        /// <summary>
+        /// Describes a named mesh morph, essentially a named list of MorphVertices
+        /// </summary>
         public struct Morph
         {
-            public string Name;
-            public int NumVertices;
-            public MorphVertex[] Vertices;
-
+            public string Name;                     //!< Name of the morph
+            public int NumVertices;                 //!< Number of vertices to distort
+            public MorphVertex[] Vertices;          //!< The actual list of morph vertices
+
+            /// <summary>
+            /// Provide a nice format for debugging
+            /// </summary>
+            /// <returns>The name of the morph</returns>
             public override string ToString()
             {
                 return Name;
             }
         }
 
+        /// <summary>
+        /// Don't really know what this does
+        /// </summary>
         public struct VertexRemap
         {
-            public int RemapSource;
-            public int RemapDestination;
+            public int RemapSource;             //!< Source index
+            public int RemapDestination;        //!< Destination index
 
+            /// <summary>
+            /// Provide a nice format for debugging
+            /// </summary>
+            /// <returns>Human friendly format</returns>
             public override string ToString()
             {
                 return String.Format("{0} -> {1}", RemapSource, RemapDestination);
             }
         }
-
         #endregion Mesh Structs
 
+        #region reference mesh
+        /// <summary>
+        /// A reference mesh is one way to implement level of detail
+        /// </summary>
+        /// <remarks>
+        /// Reference meshes are supplemental meshes to full meshes. For all practical
+        /// purposes almost all lod meshes are implemented as reference meshes, except for 
+        /// 'avatar_eye_1.llm' which for some reason is implemented as a full mesh.
+        /// </remarks>
+        public class ReferenceMesh
+        {
+            public float MinPixelWidth;                 //!< Pixel width on screen before switching to coarser lod
+
+            public string Header;                       //!< Header - marking the file as a Linden Lab Mesh (llm)
+            public bool HasWeights;                     //!< Do the vertices carry any defintions about skin weights
+            public bool HasDetailTexCoords;             //!< Do the vertices carry any defintions about detailed UV mappings
+            public Vector3 Position;                    //!< Origin of this mesh
+            public Vector3 RotationAngles;              //!< Used to reconstruct a normalized quarternion (These are *NOT* Euler rotations)
+            public byte RotationOrder;                  //!< Not used
+            public Vector3 Scale;                       //!< Scaling information
+            public ushort NumFaces;                     //!< # of polygons in the mesh
+            public Face[] Faces;                        //!< Polygons making up the mesh, the indices are into the full mesh
+
+
+            /// <summary>
+            /// Load a mesh from a stream
+            /// </summary>
+            /// <param name="filename">Filename and path of the file containing the reference mesh</param>
+            public virtual void LoadMesh(string filename)
+            {
+                using(FileStream meshStream = new FileStream(filename, FileMode.Open, FileAccess.Read))
+                using (EndianAwareBinaryReader reader = new EndianAwareBinaryReader(meshStream))
+                {
+                    Header = TrimAt0(reader.ReadString(24));
+                    if (!String.Equals(Header, MeshHeader))
+                        throw new FileLoadException("Unrecognized mesh format");
+
+                    // Populate base mesh parameters
+                    HasWeights = (reader.ReadByte() != 0);
+                    HasDetailTexCoords = (reader.ReadByte() != 0);
+                    Position = new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle());
+                    RotationAngles = new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle());
+                    RotationOrder = reader.ReadByte();
+                    Scale = new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle());
+                    NumFaces = reader.ReadUInt16();
+
+                    Faces = new Face[NumFaces];
+
+                    for (int i = 0; i < NumFaces; i++)
+                        Faces[i].Indices = new[] { reader.ReadInt16(), reader.ReadInt16(), reader.ReadInt16() };
+                }
+            }
+        }
+
         /// <summary>
         /// Level of Detail mesh
         /// </summary>
+        [Obsolete("Renamed to: ReferenceMesh")]
         public class LODMesh
         {
             public float MinPixelWidth;
@@ -119,7 +231,7 @@ namespace OpenMetaverse.Rendering
                 BitPack input = new BitPack(buffer, 0);
 
                 _header = TrimAt0(input.UnpackString(24));
-                if (!String.Equals(_header, MESH_HEADER))
+                if (!String.Equals(_header, MeshHeader))
                     return;
 
                 // Populate base mesh variables
@@ -129,7 +241,7 @@ namespace OpenMetaverse.Rendering
                 _rotationAngles = new Vector3(input.UnpackFloat(), input.UnpackFloat(), input.UnpackFloat());
                 _rotationOrder = input.UnpackByte();
                 _scale = new Vector3(input.UnpackFloat(), input.UnpackFloat(), input.UnpackFloat());
-                _numFaces = (ushort)input.UnpackUShort();
+                _numFaces = input.UnpackUShort();
 
                 _faces = new Face[_numFaces];
 
@@ -137,188 +249,304 @@ namespace OpenMetaverse.Rendering
                     _faces[i].Indices = new short[] { input.UnpackShort(), input.UnpackShort(), input.UnpackShort() };
             }
         }
+        #endregion lod mesh
 
-        public float MinPixelWidth;
+        public float MinPixelWidth;                                             //!< Width of redered avatar, before moving to a coarser LOD
 
-        public string Name { get { return _name; } }
-        public string Header { get { return _header; } }
-        public bool HasWeights { get { return _hasWeights; } }
-        public bool HasDetailTexCoords { get { return _hasDetailTexCoords; } }
-        public Vector3 Position { get { return _position; } }
-        public Vector3 RotationAngles { get { return _rotationAngles; } }
+        public string Name { get; protected set; }                              //!< The name of this mesh
+        public string Header { get; protected set; }                            //!< The header marker contained in the .llm file
+        public bool HasWeights { get; protected set; }                          //!< Does the file contain skin weights?
+        public bool HasDetailTexCoords { get; protected set; }                  //!< Does the file contain detailed UV mapings
+        public Vector3 Position { get; protected set; }                         //!< Origin of this mesh
+        public Vector3 RotationAngles { get; protected set; }                   //!< Rotation - This is a compressed quaternion
         //public byte RotationOrder
-        public Vector3 Scale { get { return _scale; } }
-        public ushort NumVertices { get { return _numVertices; } }
-        public Vertex[] Vertices { get { return _vertices; } }
-        public ushort NumFaces { get { return _numFaces; } }
-        public Face[] Faces { get { return _faces; } }
-        public ushort NumSkinJoints { get { return _numSkinJoints; } }
-        public string[] SkinJoints { get { return _skinJoints; } }
-        public Morph[] Morphs { get { return _morphs; } }
-        public int NumRemaps { get { return _numRemaps; } }
-        public VertexRemap[] VertexRemaps { get { return _vertexRemaps; } }
-        public SortedList<int, LODMesh> LODMeshes { get { return _lodMeshes; } }
-
-        protected string _name;
-        protected string _header;
-        protected bool _hasWeights;
-        protected bool _hasDetailTexCoords;
-        protected Vector3 _position;
-        protected Vector3 _rotationAngles;
-        protected byte _rotationOrder;
-        protected Vector3 _scale;
-        protected ushort _numVertices;
-        protected Vertex[] _vertices;
-        protected ushort _numFaces;
-        protected Face[] _faces;
-        protected ushort _numSkinJoints;
-        protected string[] _skinJoints;
-        protected Morph[] _morphs;
-        protected int _numRemaps;
-        protected VertexRemap[] _vertexRemaps;
-        protected SortedList<int, LODMesh> _lodMeshes;
-
-        public LindenMesh(string name)
+        public Vector3 Scale { get; protected set; }                            //!< Scale of this mesh
+        public ushort NumVertices { get; protected set; }                       //!< # of vertices in the file
+        public Vertex[] Vertices { get; protected set; }                        //!< The actual vertices defining the 3d shape
+        public ushort NumFaces { get; protected set; }                          //!< # of polygons in the file
+        public Face[] Faces { get; protected set; }                             //!< The polgon defintion
+        public ushort NumSkinJoints { get; protected set; }                     //!< # of joints influencing the mesh
+        public string[] SkinJoints { get; protected set; }                      //!< Named list of joints
+        public int NumRemaps { get; protected set; }                            //!< # of vertex remaps
+        public VertexRemap[] VertexRemaps { get; protected set; }               //!< The actual vertex remapping list
+
+        // lods can either be Reference meshes or full LindenMeshes
+        // so we cannot use a collection of specialized classes
+        public SortedList<int, object> LodMeshes { get; protected set; }        //!< The LOD meshes, available for this mesh
+
+        public Morph[] Morphs;                                                  //!< The morphs this file contains
+
+        /// <summary>
+        /// Construct a linden mesh with the given name
+        /// </summary>
+        /// <param name="name">the name of the mesh</param>
+        /// <param name="skeleton">The skeleton governing mesh deformation</param>
+        public LindenMesh(string name, LindenSkeleton skeleton = null)
         {
-            _name = name;
-            _lodMeshes = new SortedList<int, LODMesh>();
+            Name = name;
+            Skeleton = skeleton;
+            LodMeshes = new SortedList<int, object>();
+
+            if (Skeleton == null)
+                Skeleton = LindenSkeleton.Load();
         }
 
+        /// <summary>
+        /// Load the mesh from a stream
+        /// </summary>
+        /// <param name="filename">The filename and path of the file containing the mesh data</param>
         public virtual void LoadMesh(string filename)
         {
-            byte[] buffer = File.ReadAllBytes(filename);
-            BitPack input = new BitPack(buffer, 0);
-
-            _header = TrimAt0(input.UnpackString(24));
-            if (!String.Equals(_header, MESH_HEADER))
-                return;
-
-            // Populate base mesh variables
-            _hasWeights = (input.UnpackByte() != 0);
-            _hasDetailTexCoords = (input.UnpackByte() != 0);
-            _position = new Vector3(input.UnpackFloat(), input.UnpackFloat(), input.UnpackFloat());
-            _rotationAngles = new Vector3(input.UnpackFloat(), input.UnpackFloat(), input.UnpackFloat());
-            _rotationOrder = input.UnpackByte();
-            _scale = new Vector3(input.UnpackFloat(), input.UnpackFloat(), input.UnpackFloat());
-            _numVertices = (ushort)input.UnpackUShort();
-
-            // Populate the vertex array
-            _vertices = new Vertex[_numVertices];
-
-            for (int i = 0; i < _numVertices; i++)
-                _vertices[i].Coord = new Vector3(input.UnpackFloat(), input.UnpackFloat(), input.UnpackFloat());
-
-            for (int i = 0; i < _numVertices; i++)
-                _vertices[i].Normal = new Vector3(input.UnpackFloat(), input.UnpackFloat(), input.UnpackFloat());
+            using(FileStream meshData = new FileStream(filename, FileMode.Open, FileAccess.Read))
+            using (EndianAwareBinaryReader reader = new EndianAwareBinaryReader(meshData))
+            {
+                Header = TrimAt0(reader.ReadString(24));
+                if (!String.Equals(Header, MeshHeader))
+                    throw new FileLoadException("Unrecognized mesh format");
+
+                // Populate base mesh parameters
+                HasWeights = (reader.ReadByte() != 0);
+                HasDetailTexCoords = (reader.ReadByte() != 0);
+                Position = new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle());
+                RotationAngles = new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle());
+                /* RotationOrder = */ reader.ReadByte();
+                Scale = new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle());
+
+                // Populate the vertex array
+                NumVertices = reader.ReadUInt16();
+                Vertices = new Vertex[NumVertices];
+                for (int i = 0; i < NumVertices; i++)
+                    Vertices[i].Coord = new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle());
+
+                for (int i = 0; i < NumVertices; i++)
+                    Vertices[i].Normal = new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle());
+
+                for (int i = 0; i < NumVertices; i++)
+                    Vertices[i].BiNormal = new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle());
+
+                for (int i = 0; i < NumVertices; i++)
+                    Vertices[i].TexCoord = new Vector2(reader.ReadSingle(), reader.ReadSingle());
+
+                if (HasDetailTexCoords)
+                {
+                    for (int i = 0; i < NumVertices; i++)
+                        Vertices[i].DetailTexCoord = new Vector2(reader.ReadSingle(), reader.ReadSingle());
+                }
 
-            for (int i = 0; i < _numVertices; i++)
-                _vertices[i].BiNormal = new Vector3(input.UnpackFloat(), input.UnpackFloat(), input.UnpackFloat());
+                if (HasWeights)
+                {
+                    for (int i = 0; i < NumVertices; i++)
+                        Vertices[i].Weight = reader.ReadSingle();
+                }
 
-            for (int i = 0; i < _numVertices; i++)
-                _vertices[i].TexCoord = new Vector2(input.UnpackFloat(), input.UnpackFloat());
+                NumFaces = reader.ReadUInt16();
+                Faces = new Face[NumFaces];
 
-            if (_hasDetailTexCoords)
-            {
-                for (int i = 0; i < _numVertices; i++)
-                    _vertices[i].DetailTexCoord = new Vector2(input.UnpackFloat(), input.UnpackFloat());
-            }
+                for (int i = 0; i < NumFaces; i++)
+                    Faces[i].Indices = new[] { reader.ReadInt16(), reader.ReadInt16(), reader.ReadInt16() };
 
-            if (_hasWeights)
-            {
-                for (int i = 0; i < _numVertices; i++)
-                    _vertices[i].Weight = input.UnpackFloat();
-            }
+                if (HasWeights)
+                {
+                    NumSkinJoints = reader.ReadUInt16();
+                    SkinJoints = new string[NumSkinJoints];
 
-            _numFaces = input.UnpackUShort();
+                    for (int i = 0; i < NumSkinJoints; i++)
+                    {
+                        SkinJoints[i] = TrimAt0(reader.ReadString(64));
+                    }
+                }
+                else
+                {
+                    NumSkinJoints = 0;
+                    SkinJoints = new string[0];
+                }
 
-            _faces = new Face[_numFaces];
+                // Grab morphs
+                List<Morph> morphs = new List<Morph>();
+                string morphName = TrimAt0(reader.ReadString(64));
 
-            for (int i = 0; i < _numFaces; i++)
-                _faces[i].Indices = new short[] { input.UnpackShort(), input.UnpackShort(), input.UnpackShort() };
+                while (morphName != MorphFooter)
+                {
+                    if (reader.BaseStream.Position + 48 >= reader.BaseStream.Length)
+                        throw new FileLoadException("Encountered end of file while parsing morphs");
+
+                    Morph morph = new Morph();
+                    morph.Name = morphName;
+                    morph.NumVertices = reader.ReadInt32();
+                    morph.Vertices = new MorphVertex[morph.NumVertices];
+
+                    for (int i = 0; i < morph.NumVertices; i++)
+                    {
+                        morph.Vertices[i].VertexIndex = reader.ReadUInt32();
+                        morph.Vertices[i].Coord = new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle());
+                        morph.Vertices[i].Normal = new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle());
+                        morph.Vertices[i].BiNormal = new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle());
+                        morph.Vertices[i].TexCoord = new Vector2(reader.ReadSingle(), reader.ReadSingle());
+                    }
+
+                    morphs.Add(morph);
+
+                    // Grab the next name
+                    morphName = TrimAt0(reader.ReadString(64));
+                }
 
-            if (_hasWeights)
-            {
-                _numSkinJoints = input.UnpackUShort();
-                _skinJoints = new string[_numSkinJoints];
+                Morphs = morphs.ToArray();
 
-                for (int i = 0; i < _numSkinJoints; i++)
+                // Check if there are remaps or if we're at the end of the file
+                if (reader.BaseStream.Position < reader.BaseStream.Length - 1)
                 {
-                    _skinJoints[i] = TrimAt0(input.UnpackString(64));
+                    NumRemaps = reader.ReadInt32();
+                    VertexRemaps = new VertexRemap[NumRemaps];
+
+                    for (int i = 0; i < NumRemaps; i++)
+                    {
+                        VertexRemaps[i].RemapSource = reader.ReadInt32();
+                        VertexRemaps[i].RemapDestination = reader.ReadInt32();
+                    }
+                }
+                else
+                {
+                    NumRemaps = 0;
+                    VertexRemaps = new VertexRemap[0];
                 }
             }
-            else
-            {
-                _numSkinJoints = 0;
-                _skinJoints = new string[0];
-            }
-
-            // Grab morphs
-            List<Morph> morphs = new List<Morph>();
-            string morphName = TrimAt0(input.UnpackString(64));
 
-            while (morphName != MORPH_FOOTER)
+            // uncompress the skin weights
+            if (Skeleton != null)
             {
-                if (input.BytePos + 48 >= input.Data.Length) throw new FileLoadException("Encountered end of file while parsing morphs");
-
-                Morph morph = new Morph();
-                morph.Name = morphName;
-                morph.NumVertices = input.UnpackInt();
-                morph.Vertices = new MorphVertex[morph.NumVertices];
-
-                for (int i = 0; i < morph.NumVertices; i++)
+                // some meshes aren't weighted, which doesn't make much sense.
+                // we check for left and right eyeballs, and assign them a 100%
+                // to their respective bone
+                List<string> expandedJointList = Skeleton.BuildExpandedJointList(SkinJoints);
+                if (expandedJointList.Count == 0)
                 {
-                    morph.Vertices[i].VertexIndex = input.UnpackUInt();
-                    morph.Vertices[i].Coord = new Vector3(input.UnpackFloat(), input.UnpackFloat(), input.UnpackFloat());
-                    morph.Vertices[i].Normal = new Vector3(input.UnpackFloat(), input.UnpackFloat(), input.UnpackFloat());
-                    morph.Vertices[i].BiNormal = new Vector3(input.UnpackFloat(), input.UnpackFloat(), input.UnpackFloat());
-                    morph.Vertices[i].TexCoord = new Vector2(input.UnpackFloat(), input.UnpackFloat());
+                    if (Name == "eyeBallLeftMesh")
+                    {
+                        expandedJointList.AddRange(new[] { "mEyeLeft", "mSkull" });
+                    }
+                    else if (Name == "eyeBallRightMesh")
+                    {
+                        expandedJointList.AddRange(new[] { "mEyeRight", "mSkull" });
+                    }
                 }
 
-                morphs.Add(morph);
-
-                // Grab the next name
-                morphName = TrimAt0(input.UnpackString(64));
+                if (expandedJointList.Count > 0)
+                    ExpandCompressedSkinWeights(expandedJointList);
             }
+        }
 
-            _morphs = morphs.ToArray();
+        #region Skin weight
 
-            // Check if there are remaps or if we're at the end of the file
-            if (input.BytePos < input.Data.Length - 1)
+        /// <summary>
+        /// Layout of one skinweight element
+        /// </summary>
+        public struct SkinWeightElement
+        {
+            public string Bone1;        // Name of the first bone that influences the vertex
+            public string Bone2;        // Name of the second bone that influences the vertex
+            public float Weight1;       // Weight with whitch the first bone influences the vertex
+            public float Weight2;       // Weight with whitch the second bone influences the vertex
+        }
+
+        /// <summary>List of skinweights, in the same order as the mesh vertices</summary>
+        public List<SkinWeightElement> SkinWeights = new List<SkinWeightElement>();
+
+        /// <summary>
+        /// Decompress the skinweights
+        /// </summary>
+        /// <param name="expandedJointList">the expanded joint list, used to index which bones should influece the vertex</param>
+        void ExpandCompressedSkinWeights(List<string> expandedJointList)
+        {
+            for (int i = 0; i < NumVertices; i++)
             {
-                _numRemaps = input.UnpackInt();
-                _vertexRemaps = new VertexRemap[_numRemaps];
+                int boneIndex = (int)Math.Floor(Vertices[i].Weight); // Whole number part is the index
+                float boneWeight = (Vertices[i].Weight - boneIndex); // fractional part it the weight
 
-                for (int i = 0; i < _numRemaps; i++)
+                if (boneIndex == 0)         // Special case for dealing with eye meshes, which doesn't have any weights
                 {
-                    _vertexRemaps[i].RemapSource = input.UnpackInt();
-                    _vertexRemaps[i].RemapDestination = input.UnpackInt();
+                    SkinWeights.Add(new SkinWeightElement { Bone1 = expandedJointList[0], Weight1 = 1, Bone2 = expandedJointList[1], Weight2 = 0 });
+                }
+                else if (boneIndex < expandedJointList.Count)
+                {
+                    string bone1 = expandedJointList[boneIndex - 1];
+                    string bone2 = expandedJointList[boneIndex];
+                    SkinWeights.Add(new SkinWeightElement { Bone1 = bone1, Weight1 = 1 - boneWeight, Bone2 = bone2, Weight2 = boneWeight });
+                }
+                else
+                {   // this should add a weight where the "invalid" Joint has a weight of zero
+                    SkinWeights.Add(new SkinWeightElement
+                    {
+                        Bone1 = expandedJointList[boneIndex - 1],
+                        Weight1 = 1 - boneWeight,
+                        Bone2 = "mPelvis",
+                        Weight2 = boneWeight
+                    });
                 }
-            }
-            else
-            {
-                _numRemaps = 0;
-                _vertexRemaps = new VertexRemap[0];
             }
         }
+        #endregion Skin weight
 
+        [Obsolete("Use LoadLodMesh")]
         public virtual void LoadLODMesh(int level, string filename)
         {
+            if (filename == "avatar_eye_1.llm")
+                throw new ArgumentException("Eyballs are not LOD Meshes", "filename");
+
             LODMesh lod = new LODMesh();
             lod.LoadMesh(filename);
-            _lodMeshes[level] = lod;
+            LodMeshes[level] = lod;
+        }
+
+        public virtual object LoadLodMesh(int level, string filename)
+        {
+            if (filename != "avatar_eye_1.llm")
+            {
+                ReferenceMesh refMesh = new ReferenceMesh();
+                refMesh.LoadMesh(filename);
+                LodMeshes[level] = refMesh;
+                return refMesh;
+            }
+
+            LindenMesh fullMesh = new LindenMesh("");
+            fullMesh.LoadMesh(filename);
+            LodMeshes[level] = fullMesh;
+            return fullMesh;
         }
 
+        /// <summary>
+        /// Load a reference mesh from a given stream
+        /// </summary>
+        /// <param name="lodLevel">The lod level of this reference mesh</param>
+        /// <param name="filename">the name and path of the file containing the mesh data</param>
+        /// <returns>the loaded reference mesh</returns>
+        public virtual ReferenceMesh LoadReferenceMesh(int lodLevel, string filename)
+        {
+            if (filename == "avatar_eye_1.llm")
+                throw new ArgumentException("Eyballs are not LOD Meshes", "filename");
+
+            ReferenceMesh reference = new ReferenceMesh();
+            reference.LoadMesh(filename);
+            LodMeshes[lodLevel] = lodLevel;
+            return reference;
+        }
+
+        /// <summary>
+        /// Trim a string at the first occurence of NUL
+        /// </summary>
+        /// <remarks>
+        /// The llm file uses null terminated strings (C/C++ style), this is where
+        /// the conversion is made.
+        /// </remarks>
+        /// <param name="s">The string to trim</param>
+        /// <returns>A standard .Net string</returns>
         public static string TrimAt0(string s)
         {
             int pos = s.IndexOf("\0");
+
             if (pos >= 0)
-            {
                 return s.Substring(0, pos);
-            }
-            else
-            {
-                return s;
-            }
+
+            return s;
         }
     }
 }
diff --git a/Programs/AvatarPreview/GLMesh.cs b/Programs/AvatarPreview/GLMesh.cs
index 9cb3667..2651466 100644
--- a/Programs/AvatarPreview/GLMesh.cs
+++ b/Programs/AvatarPreview/GLMesh.cs
@@ -63,50 +63,50 @@ namespace AvatarPreview
             maxX = maxY = maxZ = Single.MinValue;
 
             // Generate the vertex array
-            RenderData.Vertices = new float[_numVertices * 3];
+            RenderData.Vertices = new float[NumVertices * 3];
             int current = 0;
-            for (int i = 0; i < _numVertices; i++)
+            for (int i = 0; i < NumVertices; i++)
             {
-                RenderData.Vertices[current++] = _vertices[i].Coord.X;
-                RenderData.Vertices[current++] = _vertices[i].Coord.Y;
-                RenderData.Vertices[current++] = _vertices[i].Coord.Z;
-
-                if (_vertices[i].Coord.X < minX)
-                    minX = _vertices[i].Coord.X;
-                else if (_vertices[i].Coord.X > maxX)
-                    maxX = _vertices[i].Coord.X;
-
-                if (_vertices[i].Coord.Y < minY)
-                    minY = _vertices[i].Coord.Y;
-                else if (_vertices[i].Coord.Y > maxY)
-                    maxY = _vertices[i].Coord.Y;
-
-                if (_vertices[i].Coord.Z < minZ)
-                    minZ = _vertices[i].Coord.Z;
-                else if (_vertices[i].Coord.Z > maxZ)
-                    maxZ = _vertices[i].Coord.Z;
+                RenderData.Vertices[current++] = Vertices[i].Coord.X;
+                RenderData.Vertices[current++] = Vertices[i].Coord.Y;
+                RenderData.Vertices[current++] = Vertices[i].Coord.Z;
+
+                if (Vertices[i].Coord.X < minX)
+                    minX = Vertices[i].Coord.X;
+                else if (Vertices[i].Coord.X > maxX)
+                    maxX = Vertices[i].Coord.X;
+
+                if (Vertices[i].Coord.Y < minY)
+                    minY = Vertices[i].Coord.Y;
+                else if (Vertices[i].Coord.Y > maxY)
+                    maxY = Vertices[i].Coord.Y;
+
+                if (Vertices[i].Coord.Z < minZ)
+                    minZ = Vertices[i].Coord.Z;
+                else if (Vertices[i].Coord.Z > maxZ)
+                    maxZ = Vertices[i].Coord.Z;
             }
 
             // Calculate the center-point from the bounding box edges
             RenderData.Center = new Vector3((minX + maxX) / 2, (minY + maxY) / 2, (minZ + maxZ) / 2);
 
             // Generate the index array
-            RenderData.Indices = new ushort[_numFaces * 3];
+            RenderData.Indices = new ushort[NumFaces * 3];
             current = 0;
-            for (int i = 0; i < _numFaces; i++)
+            for (int i = 0; i < NumFaces; i++)
             {
-                RenderData.Indices[current++] = (ushort)_faces[i].Indices[0];
-                RenderData.Indices[current++] = (ushort)_faces[i].Indices[1];
-                RenderData.Indices[current++] = (ushort)_faces[i].Indices[2];
+                RenderData.Indices[current++] = (ushort)Faces[i].Indices[0];
+                RenderData.Indices[current++] = (ushort)Faces[i].Indices[1];
+                RenderData.Indices[current++] = (ushort)Faces[i].Indices[2];
             }
 
             // Generate the texcoord array
-            RenderData.TexCoords = new float[_numVertices * 2];
+            RenderData.TexCoords = new float[NumVertices * 2];
             current = 0;
-            for (int i = 0; i < _numVertices; i++)
+            for (int i = 0; i < NumVertices; i++)
             {
-                RenderData.TexCoords[current++] = _vertices[i].TexCoord.X;
-                RenderData.TexCoords[current++] = _vertices[i].TexCoord.Y;
+                RenderData.TexCoords[current++] = Vertices[i].TexCoord.X;
+                RenderData.TexCoords[current++] = Vertices[i].TexCoord.Y;
             }
         }
 
@@ -114,7 +114,7 @@ namespace AvatarPreview
         {
             LODMesh lod = new LODMesh();
             lod.LoadMesh(filename);
-            _lodMeshes[level] = lod;
+            LodMeshes[level] = lod;
         }
     }
 }
-- 
1.9.4.msysgit.2


From d3af29e7b1baa339d7cd2a1a13f2e62b40e05b14 Mon Sep 17 00:00:00 2001
From: antoncl <anton.lauridsen@gmail.com>
Date: Mon, 15 Dec 2014 23:08:24 +0100
Subject: [PATCH 2/2] Added loader for the avatar_skeleton.xml file and a byte
 aligned endian aware reader

---
 OpenMetaverse/Rendering/EndianAwareBinaryReader.cs | 164 ++++++++++++++
 OpenMetaverse/Rendering/LindenSkeleton.Ext.cs      | 127 +++++++++++
 OpenMetaverse/Rendering/LindenSkeleton.Xsd.cs      | 244 +++++++++++++++++++++
 3 files changed, 535 insertions(+)
 create mode 100644 OpenMetaverse/Rendering/EndianAwareBinaryReader.cs
 create mode 100644 OpenMetaverse/Rendering/LindenSkeleton.Ext.cs
 create mode 100644 OpenMetaverse/Rendering/LindenSkeleton.Xsd.cs

diff --git a/OpenMetaverse/Rendering/EndianAwareBinaryReader.cs b/OpenMetaverse/Rendering/EndianAwareBinaryReader.cs
new file mode 100644
index 0000000..54601e2
--- /dev/null
+++ b/OpenMetaverse/Rendering/EndianAwareBinaryReader.cs
@@ -0,0 +1,164 @@
+﻿/*
+ * Copyright (c) 2006-2014, openmetaverse.org
+ * All rights reserved.
+ *
+ * - Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ * - Neither the name of the openmetaverse.org nor the names
+ *   of its contributors may be used to endorse or promote products derived from
+ *   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System;
+using System.IO;
+
+namespace OpenMetaverse.Rendering
+{
+    /// <summary>
+    /// Binary reader, which is endian aware
+    /// </summary>
+    public class EndianAwareBinaryReader : BinaryReader
+    {
+        /// What is the format of the source file
+        public enum SourceFormat
+        {
+            BigEndian,                          //!< The stream is big endian, SPARC, Arm and friends 
+            LittleEndian                        //!< x86 and friends
+        }
+
+        private byte[] m_a16 = new byte[2];                         //!< Temporary storage area for 2 byte values
+        private byte[] m_a32 = new byte[4];                         //!< Temporary storage area for 4 byte values
+        private byte[] m_a64 = new byte[8];                         //!< Temporary storage area for 8 byte values
+
+        private readonly bool m_shouldReverseOrder;                 //!< true if the file is in a different endian format than the system
+
+        /// <summary>
+        /// Construct a reader from a stream
+        /// </summary>
+        /// <param name="stream">The stream to read from</param>
+        /// <param name="format">What is the format of the file, assumes PC and similar architecture</param>
+        public EndianAwareBinaryReader(Stream stream, SourceFormat format = SourceFormat.LittleEndian)
+            : base(stream)
+        {
+            if ((format == SourceFormat.BigEndian && BitConverter.IsLittleEndian) ||
+                (format == SourceFormat.LittleEndian && !BitConverter.IsLittleEndian))
+                m_shouldReverseOrder = true;
+        }
+
+        /// <summary>
+        /// Read a 32 bit integer
+        /// </summary>
+        /// <returns>A 32 bit integer in the system's endianness</returns>
+        public override int ReadInt32()
+        {
+            m_a32 = base.ReadBytes(4);
+            if (m_shouldReverseOrder)
+                Array.Reverse(m_a32);
+            return BitConverter.ToInt32(m_a32, 0);
+        }
+
+        /// <summary>
+        /// Read a 16 bit integer
+        /// </summary>
+        /// <returns>A 16 bit integer in the system's endianness</returns>
+        public override Int16 ReadInt16()
+        {
+            m_a16 = base.ReadBytes(2);
+            if (m_shouldReverseOrder)
+                Array.Reverse(m_a16);
+            return BitConverter.ToInt16(m_a16, 0);
+        }
+
+        /// <summary>
+        /// Read a 64 bit integer
+        /// </summary>
+        /// <returns>A 64 bit integer in the system's endianness</returns>
+        public override Int64 ReadInt64()
+        {
+            m_a64 = base.ReadBytes(8);
+            if (m_shouldReverseOrder)
+                Array.Reverse(m_a64);
+            return BitConverter.ToInt64(m_a64, 0);
+        }
+
+        /// <summary>
+        /// Read an unsigned 32 bit integer
+        /// </summary>
+        /// <returns>A 32 bit unsigned integer in the system's endianness</returns>
+        public override UInt32 ReadUInt32()
+        {
+            m_a32 = base.ReadBytes(4);
+            if (m_shouldReverseOrder)
+                Array.Reverse(m_a32);
+            return BitConverter.ToUInt32(m_a32, 0);
+        }
+
+        /// <summary>
+        /// Read a single precision floating point value
+        /// </summary>
+        /// <returns>A single precision floating point value in the system's endianness</returns>
+        public override float ReadSingle()
+        {
+            m_a32 = base.ReadBytes(4);
+            if (m_shouldReverseOrder)
+                Array.Reverse(m_a32);
+            return BitConverter.ToSingle(m_a32, 0);
+        }
+
+        /// <summary>
+        /// Read a double precision floating point value
+        /// </summary>
+        /// <returns>A double precision floating point value in the system's endianness</returns>
+        public override double ReadDouble()
+        {
+            m_a64 = base.ReadBytes(8);
+            if (m_shouldReverseOrder)
+                Array.Reverse(m_a64);
+            return BitConverter.ToDouble(m_a64, 0);
+        }
+
+        /// <summary>
+        /// Read a UTF-8 string
+        /// </summary>
+        /// <returns>A standard system string</returns>
+        public override string ReadString()
+        {
+            using (MemoryStream ms = new MemoryStream())
+            {
+                byte b = ReadByte();
+                while (b != 0)
+                {
+                    ms.WriteByte(b);
+                    b = ReadByte();
+                }
+                return System.Text.Encoding.UTF8.GetString(ms.GetBuffer(), 0, (int)ms.Position);
+            }
+        }
+
+        /// <summary>
+        /// Read a UTF-8 string
+        /// </summary>
+        /// <param name="size">length of string to read</param>
+        /// <returns>A standard system string</returns>
+        public string ReadString(int size)
+        {
+            byte[] buffer = ReadBytes(size);
+            return System.Text.Encoding.UTF8.GetString(buffer).Trim();
+        }
+    }
+}
diff --git a/OpenMetaverse/Rendering/LindenSkeleton.Ext.cs b/OpenMetaverse/Rendering/LindenSkeleton.Ext.cs
new file mode 100644
index 0000000..641b81b
--- /dev/null
+++ b/OpenMetaverse/Rendering/LindenSkeleton.Ext.cs
@@ -0,0 +1,127 @@
+﻿/*
+ * Copyright (c) 2006-2014, openmetaverse.org
+ * All rights reserved.
+ *
+ * - Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ * - Neither the name of the openmetaverse.org nor the names
+ *   of its contributors may be used to endorse or promote products derived from
+ *   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using System.Xml;
+using System.Xml.Serialization;
+
+namespace OpenMetaverse.Rendering
+{
+    /// <summary>
+    /// load the 'avatar_skeleton.xml'
+    /// </summary>
+    /// <remarks>
+    /// Partial class which extends the auto-generated 'LindenSkeleton.Xsd.cs'.eton.xsd
+    /// </remarks>
+    public partial class LindenSkeleton
+   {
+        /// <summary>
+        /// Load a skeleton from a given file.
+        /// </summary>
+        /// <remarks>
+        /// We use xml scema validation on top of the xml de-serializer, since the schema has
+        /// some stricter checks than the de-serializer provides. E.g. the vector attributes
+        /// are guaranteed to hold only 3 float values. This reduces the need for error checking
+        /// while working with the loaded skeleton.
+        /// </remarks>
+        /// <param name="fileName">The path to the skeleton definition file</param>
+        /// <returns>A valid recursive skeleton</returns>
+        public static LindenSkeleton Load(string fileName = null)
+        {
+            if (fileName == null)
+                fileName = System.IO.Path.Combine(Settings.RESOURCE_DIR, "avatar_skeleton.xml");
+
+            LindenSkeleton result;
+
+            using (FileStream skeletonData = new FileStream(fileName, FileMode.Open, FileAccess.Read))
+            using (XmlReader reader = XmlReader.Create(skeletonData))
+            {
+                XmlSerializer ser = new XmlSerializer(typeof(LindenSkeleton));
+                result = (LindenSkeleton)ser.Deserialize(reader);
+            }
+            return result;
+        }
+
+        /// <summary>
+        /// Build and "expanded" list of joints
+        /// </summary>
+        /// <remarks>
+        /// The algorithm is based on this description:
+        /// 
+        /// >An "expanded" list of joints, not just a
+        /// >linear array of the joints as defined in the skeleton file.
+        /// >In particular, any joint that has more than one child will
+        /// >be repeated in the list for each of its children.
+        /// </remarks>
+        /// <param name="jointsFilter">The list should only take these joint names in consideration</param>
+        /// <returns>An "expanded" joints list as a flat list of bone names</returns>
+        public List<string> BuildExpandedJointList(IEnumerable<string> jointsFilter)
+        {
+            List<string> expandedJointList = new List<string>();
+
+            // not really sure about this algorithm, but it seems to fit the bill:
+            // and the mesh doesn't seem to be overly distorted
+            if(bone.bone != null)
+                foreach (Joint child in bone.bone)
+                    ExpandJoint(bone, child, expandedJointList, jointsFilter);
+
+            return expandedJointList;
+        }
+
+        /// <summary>
+        /// Expand one joint
+        /// </summary>
+        /// <param name="parentJoint">The parent of the joint we are operating on</param>
+        /// <param name="currentJoint">The joint we are supposed to expand</param>
+        /// <param name="expandedJointList">Joint list that we will extend upon</param>
+        /// <param name="jointsFilter">The expanded list should only contain these joints</param>
+        private void ExpandJoint(Joint parentJoint, Joint currentJoint, List<string> expandedJointList, IEnumerable<string> jointsFilter)
+        {
+            // does the mesh reference this joint
+            if (jointsFilter.Contains(currentJoint.name))
+            {
+                if (expandedJointList.Count > 0 && parentJoint != null &&
+                    parentJoint.name == expandedJointList[expandedJointList.Count - 1])
+                    expandedJointList.Add(currentJoint.name);
+                else
+                {
+                    if (parentJoint != null)
+                        expandedJointList.Add(parentJoint.name);
+                    else
+                        expandedJointList.Add(currentJoint.name);        // only happens on the root joint
+
+                    expandedJointList.Add(currentJoint.name);
+                }
+            }
+
+            // recurse the joint hierarchy
+            if(currentJoint.bone != null)
+                foreach (Joint child in currentJoint.bone)
+                    ExpandJoint(currentJoint, child, expandedJointList, jointsFilter);
+        }
+    }
+}
diff --git a/OpenMetaverse/Rendering/LindenSkeleton.Xsd.cs b/OpenMetaverse/Rendering/LindenSkeleton.Xsd.cs
new file mode 100644
index 0000000..013d338
--- /dev/null
+++ b/OpenMetaverse/Rendering/LindenSkeleton.Xsd.cs
@@ -0,0 +1,244 @@
+﻿namespace OpenMetaverse.Rendering
+{
+    //------------------------------------------------------------------------------
+    // <auto-generated>
+    //     This code was generated by a tool.
+    //     Runtime Version:4.0.30319.18444
+    //
+    //     Changes to this file may cause incorrect behavior and will be lost if
+    //     the code is regenerated.
+    // </auto-generated>
+    //------------------------------------------------------------------------------
+
+    // 
+    // This source code was auto-generated by xsd, Version=4.0.30319.1.
+    // 
+
+    using System.Xml.Serialization;
+
+    /// <remarks/>
+    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.0.30319.1")]
+    [System.SerializableAttribute()]
+    [System.ComponentModel.DesignerCategoryAttribute("code")]
+    [XmlRoot("linden_skeleton", Namespace = "", IsNullable = false)]
+    public partial class LindenSkeleton
+    {
+
+        private Joint boneField;
+
+        private float versionField;
+
+        private bool versionFieldSpecified;
+
+        private string num_bonesField;
+
+        private string num_collision_volumesField;
+
+        /// <remarks/>
+        public Joint bone
+        {
+            get
+            {
+                return this.boneField;
+            }
+            set
+            {
+                this.boneField = value;
+            }
+        }
+
+        /// <remarks/>
+        [XmlAttribute()]
+        public float version
+        {
+            get
+            {
+                return this.versionField;
+            }
+            set
+            {
+                this.versionField = value;
+            }
+        }
+
+        /// <remarks/>
+        [XmlIgnore()]
+        public bool versionSpecified
+        {
+            get
+            {
+                return this.versionFieldSpecified;
+            }
+            set
+            {
+                this.versionFieldSpecified = value;
+            }
+        }
+
+        /// <remarks/>
+        [XmlAttribute(DataType = "positiveInteger")]
+        public string num_bones
+        {
+            get
+            {
+                return this.num_bonesField;
+            }
+            set
+            {
+                this.num_bonesField = value;
+            }
+        }
+
+        /// <remarks/>
+        [XmlAttribute(DataType = "positiveInteger")]
+        public string num_collision_volumes
+        {
+            get
+            {
+                return this.num_collision_volumesField;
+            }
+            set
+            {
+                this.num_collision_volumesField = value;
+            }
+        }
+    }
+
+    /// <remarks/>
+    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.0.30319.1")]
+    [System.SerializableAttribute()]
+    [System.ComponentModel.DesignerCategoryAttribute("code")]
+    public partial class Joint : JointBase
+    {
+
+        private CollisionVolume[] collision_volumeField;
+
+        private Joint[] boneField;
+
+        private float[] pivotField;
+
+        /// <remarks/>
+        [XmlElement("collision_volume")]
+        public CollisionVolume[] collision_volume
+        {
+            get
+            {
+                return this.collision_volumeField;
+            }
+            set
+            {
+                this.collision_volumeField = value;
+            }
+        }
+
+        /// <remarks/>
+        [XmlElement("bone")]
+        public Joint[] bone
+        {
+            get
+            {
+                return this.boneField;
+            }
+            set
+            {
+                this.boneField = value;
+            }
+        }
+
+        /// <remarks/>
+        [XmlAttribute()]
+        public float[] pivot
+        {
+            get
+            {
+                return this.pivotField;
+            }
+            set
+            {
+                this.pivotField = value;
+            }
+        }
+    }
+
+    /// <remarks/>
+    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.0.30319.1")]
+    [System.SerializableAttribute()]
+    [System.ComponentModel.DesignerCategoryAttribute("code")]
+    public partial class CollisionVolume : JointBase
+    {
+    }
+
+    /// <remarks/>
+    [XmlInclude(typeof(Joint))]
+    [XmlInclude(typeof(CollisionVolume))]
+    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.0.30319.1")]
+    [System.SerializableAttribute()]
+    [System.ComponentModel.DesignerCategoryAttribute("code")]
+    public partial class JointBase
+    {
+
+        private string nameField;
+
+        private float[] posField;
+
+        private float[] rotField;
+
+        private float[] scaleField;
+
+        /// <remarks/>
+        [XmlAttribute(DataType = "token")]
+        public string name
+        {
+            get
+            {
+                return this.nameField;
+            }
+            set
+            {
+                this.nameField = value;
+            }
+        }
+
+        /// <remarks/>
+        [XmlAttribute()]
+        public float[] pos
+        {
+            get
+            {
+                return this.posField;
+            }
+            set
+            {
+                this.posField = value;
+            }
+        }
+
+        /// <remarks/>
+        [XmlAttribute()]
+        public float[] rot
+        {
+            get
+            {
+                return this.rotField;
+            }
+            set
+            {
+                this.rotField = value;
+            }
+        }
+
+        /// <remarks/>
+        [XmlAttribute()]
+        public float[] scale
+        {
+            get
+            {
+                return this.scaleField;
+            }
+            set
+            {
+                this.scaleField = value;
+            }
+        }
+    }
+}
-- 
1.9.4.msysgit.2

